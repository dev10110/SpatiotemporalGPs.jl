var documenterSearchIndex = {"docs":
[{"location":"stgpkf/#Spatiotemporal-Gaussian-Process-Kalman-Filtering","page":"STGPKF","title":"Spatiotemporal Gaussian Process Kalman Filtering","text":"","category":"section"},{"location":"stgpkf/#Theory","page":"STGPKF","title":"Theory","text":"","category":"section"},{"location":"stgpkf/","page":"STGPKF","title":"STGPKF","text":"STGPKF is a modelling technique to estimate the state of an environment.","category":"page"},{"location":"stgpkf/","page":"STGPKF","title":"STGPKF","text":"In particular, the goal is to estimate a spatiotemporal field ","category":"page"},{"location":"stgpkf/","page":"STGPKF","title":"STGPKF","text":"f  mathcalR times mathcalD to mathcalR","category":"page"},{"location":"stgpkf/","page":"STGPKF","title":"STGPKF","text":"i.e., f(t p) is the value of the field at time t and position p in mathcalD subset mathcalR^d. ","category":"page"},{"location":"stgpkf/","page":"STGPKF","title":"STGPKF","text":"The assumption is that the field is a realization of a Gaussian Process:","category":"page"},{"location":"stgpkf/","page":"STGPKF","title":"STGPKF","text":"f sim operatornameGP(m k)","category":"page"},{"location":"stgpkf/","page":"STGPKF","title":"STGPKF","text":"with mean function m(t p) = 0 and kernel function ","category":"page"},{"location":"stgpkf/","page":"STGPKF","title":"STGPKF","text":"k(t t p p) = k_t(t t) k_s(p p)","category":"page"},{"location":"stgpkf/","page":"STGPKF","title":"STGPKF","text":"Notice, we explicitly assume the kernel is separable in space and time. ","category":"page"},{"location":"stgpkf/","page":"STGPKF","title":"STGPKF","text":"Modules = [STGPKF]\nPrivate = false","category":"page"},{"location":"stgpkf/#SpatiotemporalGPs.STGPKF.STGPKFProblem-NTuple{4, Any}-stgpkf","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.STGPKFProblem","text":"STGPKFProblem(pts, ks, kt, ΔT)\n\nDefines a spatiotemporal Gaussian Process Kalman Filter problem. Parameters are:\n\npts: grid points, a vector of all points. Ideally, eltype(pts) should be StaticVector for efficiency \nks: spatial kernel, must be of type AbstractKernel\nkt: temporal kernel, must be of type AbstractKernel (but only AbstractMaternKernel is implemented)\nΔT: sampling period\n\n\n\n\n\n","category":"method"},{"location":"stgpkf/#SpatiotemporalGPs.STGPKF.Matern-Tuple{Any, Any, Any}-stgpkf","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.Matern","text":"Matern(order, σ, l)\n\ncreates a Matern kernel with order order, variance σ, and lengthscale l.  Order must be (1/2, 3/2, or 5/2). Returns a Matern12, Matern32, or Matern52 kernel.\n\n\n\n\n\n","category":"method"},{"location":"stgpkf/#SpatiotemporalGPs.STGPKF.SquaredExponential-Tuple{Any, Any}-stgpkf","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.SquaredExponential","text":"SquaredExponential(σ, l)\n\ncreates a Squared Exponential kernel with variance σ and lengthscale l. Returns a SqExp kernel.\n\n\n\n\n\n","category":"method"},{"location":"stgpkf/#SpatiotemporalGPs.STGPKF.kernel_matrix-Union{Tuple{KK}, Tuple{VPY}, Tuple{VPX}, Tuple{PY}, Tuple{PX}, Tuple{KK, VPX, VPY}} where {PX, PY, VPX<:AbstractVector{PX}, VPY<:AbstractVector{PY}, KK<:SpatiotemporalGPs.STGPKF.AbstractKernel}-stgpkf","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.kernel_matrix","text":"kernel_matrix(kernel, X, Y)\n\nCompute the kernel matrix between two sets of points X and Y using the kernel function kernel. X must be a vector of points Y must be a vector of points\n\n\n\n\n\n","category":"method"},{"location":"stgpkf/#SpatiotemporalGPs.STGPKF.stgpkf_correct-Union{Tuple{F}, Tuple{P}, Tuple{STGPKFProblem{P, F, VP, KS, KT, DTSS, M1, M2} where {VP<:AbstractVector{P}, KS<:SpatiotemporalGPs.STGPKF.AbstractKernel, KT<:SpatiotemporalGPs.STGPKF.AbstractKernel, DTSS<:SpatiotemporalGPs.STGPKF.DiscreteTimeStateSpaceModel, M1<:AbstractMatrix{F}, M2<:AbstractMatrix{F}}, KFState, P, F, F}} where {P, F}-stgpkf","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.stgpkf_correct","text":"stgpkf_correct(prob, state, pt, y, σ_m)\n\ncorrects the state of the Kalman Filter given a single point measurement at pt with value y and measurement noise standard deviation σ_m.\n\n\n\n\n\n","category":"method"},{"location":"stgpkf/#SpatiotemporalGPs.STGPKF.stgpkf_correct-Union{Tuple{MF}, Tuple{VF}, Tuple{VP}, Tuple{F}, Tuple{P}, Tuple{STGPKFProblem{P, F, VP, KS, KT, DTSS, M1, M2} where {VP<:AbstractVector{P}, KS<:SpatiotemporalGPs.STGPKF.AbstractKernel, KT<:SpatiotemporalGPs.STGPKF.AbstractKernel, DTSS<:SpatiotemporalGPs.STGPKF.DiscreteTimeStateSpaceModel, M1<:AbstractMatrix{F}, M2<:AbstractMatrix{F}}, KFState, VP, VF, MF}} where {P, F, VP<:AbstractVector{P}, VF<:AbstractVector{F}, MF<:AbstractMatrix{F}}-stgpkf","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.stgpkf_correct","text":"stgpkf_correct(prob, state, pts, ys, Σm)\n\ncorrects the state of the Kalman Filter given multiple point measurements at pts with values ys and measurement noise covariance matrix Σm.\n\n\n\n\n\n","category":"method"},{"location":"stgpkf/#SpatiotemporalGPs.STGPKF.stgpkf_initialize-Tuple{STGPKFProblem}-stgpkf","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.stgpkf_initialize","text":"stgpkf_initialize(problem)\n\nreturns a  KFState that represents the initial state of the Kalman Filter for all grid points\n\n\n\n\n\n","category":"method"},{"location":"stgpkf/#SpatiotemporalGPs.STGPKF.stgpkf_predict-Tuple{STGPKFProblem, KFState}-stgpkf","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.stgpkf_predict","text":"stgpkf_predict(prob, state)\n\npredicts the next state of the Kalman Filter for all grid points\n\n\n\n\n\n","category":"method"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#Import","page":"Quickstart","title":"Import","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using StaticArrays, LinearAlgebra, Plots\nusing SpatiotemporalGPs","category":"page"},{"location":"quickstart/#Define-the-Problem-Domain","page":"Quickstart","title":"Define the Problem Domain","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"# setup the spatial and temporal kernels\nσt = 2.0   # m/s\nσs = 1.0   # m/s\nlt = 3*60.0  # minutes\nls = 3.0   # km\n\nkt = Matern(3/2, σt, lt)\nks = Matern(1/2, σs, ls)\n\n# determine the temporal step size\nΔt = 5.0 # minutes\nΔx = 0.25 # km\n\n# create the spatial domain\nxs = 0:Δx:7.0\nys = 0:Δx:10.0\n\ngrid_pts = vec([@SVector[x, y] for x in xs, y in ys]);","category":"page"},{"location":"quickstart/#Initialize","page":"Quickstart","title":"Initialize","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"problem = STGPKFProblem(grid_pts, ks, kt, Δt)\nstate_initial = stgpkf_initialize(problem) ","category":"page"},{"location":"quickstart/#Assimilate-a-single-point-measurement","page":"Quickstart","title":"Assimilate a single point measurement","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"\n# for a single measurement\nmeasured_pt = @SVector [ ... ] \nmeasured_value = ...\nmeasured_σ = ...\n\nstate_corrected = stgpkf_correct(problem, state_initial, measured_pt, measured_y, measured_σ)","category":"page"},{"location":"quickstart/#Assimilate-a-set-of-measurements","page":"Quickstart","title":"Assimilate a set of measurements","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"\n# define all the measurements\nmeasured_pts = [ ... ] # should be a vector of positions that were measured\nmeasured_ys = [ ... ] # should be a vector of measured values\nmeasured_Σ = [ ... ]  # should be a pos def matrix\n\n\nstate_corrected = stgpkf_correct(problem, state_initial, measured_pts, measured_ys, measured_Σ)","category":"page"},{"location":"quickstart/#Predict-the-next-timestemp","page":"Quickstart","title":"Predict the next timestemp","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"\nstate_predicted = stgpkf_predict(problem, state_corrected)","category":"page"},{"location":"quickstart/#Generate-Plots","page":"Quickstart","title":"Generate Plots","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"plot(problem, state; plot_type=:estimate, kwargs...)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"where plot_type can be :estimate, :std, :clarity, :percentile. If it is percentile use the percentile=0.95 kwarg to specify which percentile to visualize. Currently only supports visualization of 2D domains. ","category":"page"},{"location":"quickstart/#Extract-Data","page":"Quickstart","title":"Extract Data","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To get the estimate of the spatiotemporal field","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"get_estimate(problem, state)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"or you can also call","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"get_estimate_covariance(problem, state)\nget_estimate_std(problem, state)\nget_estimate_clarity(problem, state)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"See examples/synthetic_data.ipynb for a full demo. ","category":"page"},{"location":"api/kf/#Kalman-Filter","page":"Kalman Filters","title":"Kalman Filter","text":"","category":"section"},{"location":"api/kf/","page":"Kalman Filters","title":"Kalman Filters","text":"Modules = [KalmanFilter] ","category":"page"},{"location":"api/kf/#SpatiotemporalGPs.KalmanFilter.KFState","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.KFState","text":"KFState{V, MU}\n\nA type for the Kalman Filter State, which is parameterized by the types of the mean estimate and the upper triangular cholesky component of the covariance matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/kf/#SpatiotemporalGPs.KalmanFilter.KFState-Tuple{}","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.KFState","text":"KFState(; μ, Σ, make_symmetric=true)\n\nA constructor for the Kalman Filter State, which is parameterized by the mean estimate and the covariance matrix. If make_symmetric is true, the covariance matrix is made symmetric internally. This is useful for numerical stability.\n\n\n\n\n\n","category":"method"},{"location":"api/kf/#LinearAlgebra.cholesky-Tuple{LinearAlgebra.Cholesky}","page":"Kalman Filters","title":"LinearAlgebra.cholesky","text":"M = cholesky(M::Cholesky)\n\nThis is a dummy method to allow for the cholesky method to be called on a cholesky decomposition.\n\n\n\n\n\n","category":"method"},{"location":"api/kf/#SpatiotemporalGPs.KalmanFilter.chol_sqrt-Tuple{Any}","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.chol_sqrt","text":"U = chol_sqrt(A)\n\nreturns an upper-triangular matrix U such that A = U^T U.\n\n\n\n\n\n","category":"method"},{"location":"api/kf/#SpatiotemporalGPs.KalmanFilter.correct-Union{Tuple{S}, Tuple{S, Any, Any, Any}} where S<:KFState","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.correct","text":"s_{k+1|k+1} = correct(s_{k+1|k}, y_{k+1}, C, V)\n\nUses the system model\n\ny_k+1 = C x_k+1 + v\n\nwhere v sim mathcalN(0 V) to correct the predicted state.\n\n\n\n\n\n","category":"method"},{"location":"api/kf/#SpatiotemporalGPs.KalmanFilter.diag-Union{Tuple{LinearAlgebra.Cholesky{T}}, Tuple{T}, Tuple{LinearAlgebra.Cholesky{T}, Int64}} where T","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.diag","text":"diag(M::Cholesky)\n\nis a fast method for getting the diagonal of a cholesky matrix.\n\nThis will eventually be included into the Julia standard library.  https://github.com/JuliaLang/julia/pull/53767\n\n\n\n\n\n","category":"method"},{"location":"api/kf/#SpatiotemporalGPs.KalmanFilter.filter-Union{Tuple{S}, Tuple{S, Vararg{Any, 7}}} where S<:KFState","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.filter","text":"s_{k+1} = filter(s_k, y_{k+1}, u_k, A, B, C, V, W)\n\nRuns both the prediction and the correction steps. Assumes a system model\n\n  beginalign\n  x_k+1 = A x_k + B u_k + w \n  y_k = C x_k + v\n  endalign\n\nwhere w  mathcalN(0 W), v  mathcalN(0 V).\n\n\n\n\n\n","category":"method"},{"location":"api/kf/#SpatiotemporalGPs.KalmanFilter.get_Σ-Tuple{S} where S<:KFState","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.get_Σ","text":"get_Σ(s::S) where {S <: KFState}\n\nGet the covariance matrix of the Kalman Filter State.\n\n\n\n\n\n","category":"method"},{"location":"api/kf/#SpatiotemporalGPs.KalmanFilter.get_μ-Tuple{S} where S<:KFState","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.get_μ","text":"get_μ(s::S) where {S <: KFState}\n\nGet the mean estimate of the Kalman Filter State.\n\n\n\n\n\n","category":"method"},{"location":"api/kf/#SpatiotemporalGPs.KalmanFilter.get_σ-Tuple{S} where S<:KFState","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.get_σ","text":"get_σ(s::S) where {S <: KFState}\n\nGet a vector of the standard deviation of the Kalman Filter State\n\n\n\n\n\n","category":"method"},{"location":"api/kf/#SpatiotemporalGPs.KalmanFilter.predict-Union{Tuple{S}, Tuple{S, Any, Any}} where S<:KFState","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.predict","text":"s_{k+1|k} = predict(s_{k|k}, A, W)\n\nUses the system model\n\n  x_k+1 = A x_k + w\n\nwhere w  N(0 W) to predict the next state.\n\n\n\n\n\n","category":"method"},{"location":"api/kf/#SpatiotemporalGPs.KalmanFilter.predict-Union{Tuple{S}, Tuple{S, Vararg{Any, 4}}} where S<:KFState","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.predict","text":"  s_{k+1} = predict(s_k, A, B, u_k, W)\n\nUses the system model\n\n  x_k+1 = A x_k + B u_k  + w\n\nwhere w  mathcalN(0 W) to predict the next state.\n\n\n\n\n\n","category":"method"},{"location":"api/kf/#SpatiotemporalGPs.KalmanFilter.qrr-Tuple{Any, Any}","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.qrr","text":"R = qrr(A, B)\n\nreturns \n\nR = sqrtA^TA + B^TB\n\nThe result is an UpperTriangular matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#STGPKP","page":"STGPKF","title":"STGPKP","text":"","category":"section"},{"location":"api/stgpkf/","page":"STGPKF","title":"STGPKF","text":"Modules = [STGPKF]","category":"page"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.STGPKFProblem-NTuple{4, Any}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.STGPKFProblem","text":"STGPKFProblem(pts, ks, kt, ΔT)\n\nDefines a spatiotemporal Gaussian Process Kalman Filter problem. Parameters are:\n\npts: grid points, a vector of all points. Ideally, eltype(pts) should be StaticVector for efficiency \nks: spatial kernel, must be of type AbstractKernel\nkt: temporal kernel, must be of type AbstractKernel (but only AbstractMaternKernel is implemented)\nΔT: sampling period\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.Matern-Tuple{Any, Any, Any}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.Matern","text":"Matern(order, σ, l)\n\ncreates a Matern kernel with order order, variance σ, and lengthscale l.  Order must be (1/2, 3/2, or 5/2). Returns a Matern12, Matern32, or Matern52 kernel.\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.SquaredExponential-Tuple{Any, Any}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.SquaredExponential","text":"SquaredExponential(σ, l)\n\ncreates a Squared Exponential kernel with variance σ and lengthscale l. Returns a SqExp kernel.\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.checkdims-Tuple{STGPKFProblem, KFState}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.checkdims","text":"checkdims(prob, state)\n\nchecks that the dimensions of the state and the problem match\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.get_estimate-Tuple{STGPKFProblem, KFState}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.get_estimate","text":"get_estimate(problem, state)\n\nreturns the estimate of the Kalman Filter for all grid points, in a Vector{F} format. The outer vector has same length as problem.pts.\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.get_estimate_clarity-Tuple{STGPKFProblem, KFState}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.get_estimate_clarity","text":"get_estimate_clarities(problem, state)\n\nreturns the clarity of the estimated spatiotemporal field at all grid points, in a Vector{F} format. The vector has same length as problem.pts.\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.get_estimate_covariance-Tuple{STGPKFProblem, KFState}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.get_estimate_covariance","text":"get_estimate_covariance(problem, state)\n\nreturns the kalman filter's covariance of the estimated spatiotemporal field at all grid points, in a Vector{F} format.  The vector has same length as problem.pts.\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.get_estimate_percentile-Tuple{STGPKFProblem, KFState, Any}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.get_estimate_percentile","text":"get_estimate_percentile(problem, state, percentile)\n\nreturns the percentile-% quantile of the estimated spatiotemporal field at all grid points, in a Vector{F} format. The vector has same length as problem.pts.\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.get_estimate_std-Tuple{STGPKFProblem, KFState}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.get_estimate_std","text":"get_estimate_std(problem, state)\n\nreturns the standard deviation of the estimated spatiotemporal field at all grid points, in a Vector{F} format. The vector has same length as problem.pts.\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.get_marginal_states-Tuple{STGPKFProblem, KFState}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.get_marginal_states","text":"get_marginal_states(problem, state)\n\nreturns the marginal states of the Kalman Filter for all grid points, in a Vector{KFState} format. The outer vector has same length as problem.pts.\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.get_states-Tuple{STGPKFProblem, KFState}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.get_states","text":"get_states(problem, state)\n\nreturns the states of the Kalman Filter for all grid points, in a Vector{SVector{F}} format. The outer vector has same length as problem.pts.\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.kernel_matrix-Union{Tuple{KK}, Tuple{VPY}, Tuple{VPX}, Tuple{PY}, Tuple{PX}, Tuple{KK, VPX, VPY}} where {PX, PY, VPX<:AbstractVector{PX}, VPY<:AbstractVector{PY}, KK<:SpatiotemporalGPs.STGPKF.AbstractKernel}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.kernel_matrix","text":"kernel_matrix(kernel, X, Y)\n\nCompute the kernel matrix between two sets of points X and Y using the kernel function kernel. X must be a vector of points Y must be a vector of points\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.quantile-Tuple{Any, Any, Any}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.quantile","text":"quantile(μ, σ, q)\n\nFor a normal distribution with mean μ and standard deviation σ, this function returns the q-th quantile.\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.stgpkf_correct-Union{Tuple{F}, Tuple{P}, Tuple{STGPKFProblem{P, F, VP, KS, KT, DTSS, M1, M2} where {VP<:AbstractVector{P}, KS<:SpatiotemporalGPs.STGPKF.AbstractKernel, KT<:SpatiotemporalGPs.STGPKF.AbstractKernel, DTSS<:SpatiotemporalGPs.STGPKF.DiscreteTimeStateSpaceModel, M1<:AbstractMatrix{F}, M2<:AbstractMatrix{F}}, KFState, P, F, F}} where {P, F}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.stgpkf_correct","text":"stgpkf_correct(prob, state, pt, y, σ_m)\n\ncorrects the state of the Kalman Filter given a single point measurement at pt with value y and measurement noise standard deviation σ_m.\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.stgpkf_correct-Union{Tuple{MF}, Tuple{VF}, Tuple{VP}, Tuple{F}, Tuple{P}, Tuple{STGPKFProblem{P, F, VP, KS, KT, DTSS, M1, M2} where {VP<:AbstractVector{P}, KS<:SpatiotemporalGPs.STGPKF.AbstractKernel, KT<:SpatiotemporalGPs.STGPKF.AbstractKernel, DTSS<:SpatiotemporalGPs.STGPKF.DiscreteTimeStateSpaceModel, M1<:AbstractMatrix{F}, M2<:AbstractMatrix{F}}, KFState, VP, VF, MF}} where {P, F, VP<:AbstractVector{P}, VF<:AbstractVector{F}, MF<:AbstractMatrix{F}}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.stgpkf_correct","text":"stgpkf_correct(prob, state, pts, ys, Σm)\n\ncorrects the state of the Kalman Filter given multiple point measurements at pts with values ys and measurement noise covariance matrix Σm.\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.stgpkf_initialize-Tuple{STGPKFProblem}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.stgpkf_initialize","text":"stgpkf_initialize(problem)\n\nreturns a  KFState that represents the initial state of the Kalman Filter for all grid points\n\n\n\n\n\n","category":"method"},{"location":"api/stgpkf/#SpatiotemporalGPs.STGPKF.stgpkf_predict-Tuple{STGPKFProblem, KFState}","page":"STGPKF","title":"SpatiotemporalGPs.STGPKF.stgpkf_predict","text":"stgpkf_predict(prob, state)\n\npredicts the next state of the Kalman Filter for all grid points\n\n\n\n\n\n","category":"method"},{"location":"example/synthetic_data/#Full-Example-with-Synthetic-Data","page":"Example","title":"Full Example with Synthetic Data","text":"","category":"section"},{"location":"example/synthetic_data/#Define-the-Problem","page":"Example","title":"Define the Problem","text":"","category":"section"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"using SpatiotemporalGPs\nusing StaticArrays, LinearAlgebra, Plots","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"# setup the spatial and temporal kernels\nσt = 2.0   # m/s\nσs = 1.0   # m/s\nlt = 3*60.0  # minutes\nls = 3.0   # km\n\nkt = Matern(3/2, σt, lt)\nks = Matern(1/2, σs, ls)\n\n# determine the temporal step size\nΔt = 5.0 # minutes\nΔx = 0.25 # km\n\n# create the spatial domain\nxs = 0:Δx:7.0\nys = 0:Δx:10.0\n\ngrid_pts = vec([@SVector[x, y] for x in xs, y in ys]);","category":"page"},{"location":"example/synthetic_data/#Create-Synthetic-Data","page":"Example","title":"Create Synthetic Data","text":"","category":"section"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"# let us generate the synthetic data first\ntmax = 4 * 60.0 # minutes\nsynthetic_data = STGPKF.generate_spatiotemporal_process(xs, ys, Δt, tmax, ks, kt);\n\n# visualize the ground truth data\n@gif for k=1:length(synthetic_data.ts)\n    heatmap(synthetic_data.xs, synthetic_data.ys, synthetic_data.data[:, :, k]', clims=(-5,5))\n    title!(\"k = $k\")\n    xlabel!(\"x\")\n    ylabel!(\"y\")\n    plot!(aspect_ratio=:equal)\nend","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"Lets start estimating...","category":"page"},{"location":"example/synthetic_data/#Initializing","page":"Example","title":"Initializing","text":"","category":"section"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"# Create the STGPKF Problem\nproblem = STGPKFProblem(grid_pts, ks, kt, Δt)\n\n# Construct the state at time 0 conditioned on no measurements\nstate_initial = stgpkf_initialize(problem) ","category":"page"},{"location":"example/synthetic_data/#Correcting-with-measurements","page":"Example","title":"Correcting with measurements","text":"","category":"section"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"# take some measurements\nfunction rand_point(xs, ys)\n    xmin, xmax = extrema(xs)\n    ymin, ymax = extrema(ys)\n    x = (xmax - xmin) * rand() + xmin\n    y = (ymax - ymin) * rand() + ymin\n    return @SVector [x, y]\nend\n\nfunction measure(data, x, y, t, σ_m=0.1)\n    return data.itp(x, y, t) + σ_m *randn()\nend\n\nmeasure_pt = rand_point(xs, ys)\nmeasure_σ = 0.1 # m/s\nmeasure_y = measure(synthetic_data, measure_pt..., synthetic_data.ts[1], measure_σ);\n\n# Do a correction\nstate_1_1 = stgpkf_correct(problem, state_initial, measure_pt, measure_y, measure_σ)\n\n# plot the resulting state\nplot(problem, state_1_1; plot_type=:estimate, clims=(-5, 5), cmap=:bluesreds, aspect_ratio=:equal)\nscatter!([measure_pt[1]], [measure_pt[2]], label=\"measured pt\")","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"plot(problem, state_1_1; plot_type=:std, clims=(0, 3), aspect_ratio=:equal)","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"plot(problem, state_1_1; plot_type=:clarity, clims=(0, 1), aspect_ratio=:equal)","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"example/synthetic_data/#Predicting","page":"Example","title":"Predicting","text":"","category":"section"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"# propagate to the next time step\nstate_2_1 = stgpkf_predict(problem, state_1_1)\n\n# plot\np0 = plot(synthetic_data, synthetic_data.ts[2]; clims=(-5, 5), cmap = :bluesreds, aspect_ratio=:equal)\ntitle!(\"synthetic data\")\np1 = plot(problem, state_2_1; plot_type=:estimate, clims=(-5, 5), cmap=:bluesreds, aspect_ratio=:equal)\np2 = plot(problem, state_2_1; plot_type=:clarity, clims=(0, 1), aspect_ratio=:equal)\nplot(p0, p1, p2, layout=(@layout [a b c]), size=(900, 600))","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"example/synthetic_data/#Measuring-multiple-points","page":"Example","title":"Measuring multiple points","text":"","category":"section"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"# measure at a 10 different points at the same time\nmeasure_pts = [rand_point(xs, ys) for i=1:10]\nmeasure_ys = [measure(synthetic_data, pt..., synthetic_data.ts[2], measure_σ) for pt in measure_pts]\nmeasure_Σ = (measure_σ^2) * I(10);\n\n# do the KF correction\nstate_2_2 = stgpkf_correct(problem, state_2_1, measure_pts, measure_ys, measure_Σ)\n\n# plot results\np0 = plot(synthetic_data, synthetic_data.ts[2]; clims=(-5, 5), cmap = :bluesreds, aspect_ratio=:equal)\ntitle!(\"synthetic data\")\nscatter!(first.(measure_pts), last.(measure_pts), label=\"measure pts\")\np1 = plot(problem, state_2_2; plot_type=:estimate, clims=(-5, 5), cmap=:bluesreds, aspect_ratio=:equal)\np2 = plot(problem, state_2_2; plot_type=:clarity, clims=(0, 1), aspect_ratio=:equal)\nplot(p0, p1, p2, layout=(@layout [a b c]), size=(900, 600))","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"example/synthetic_data/#Do-a-Whole-Simulation","page":"Example","title":"Do a Whole Simulation","text":"","category":"section"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"# initialize\nstate = stgpkf_initialize(problem) \n\nstates = (typeof(state))[]\n\nfor k=1:length(synthetic_data.ts)\n\n    @show k\n\n    # make some measurements\n    measure_pts = [rand_point(xs, ys) for i=1:10]\n    measure_ys = [measure(synthetic_data, pt..., synthetic_data.ts[k], measure_σ) for pt in measure_pts]\n    measure_Σ = (measure_σ^2) * I(10);\n\n    # do the KF correction\n    state_correction = stgpkf_correct(problem, state, measure_pts, measure_ys, measure_Σ)\n\n    # add it to the states\n    push!(states, state_correction)\n\n    # do a prediction\n    state = stgpkf_predict(problem, state_correction)\n\nend","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"Animate the results!","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"@gif for k=1:length(states)\n    p0 = plot(synthetic_data, synthetic_data.ts[k]; clims=(-5, 5), cmap = :bluesreds, aspect_ratio=:equal)\n    title!(\"synthetic data\")\n    p1 = plot(problem, states[k]; plot_type=:estimate, clims=(-5, 5), cmap=:bluesreds, aspect_ratio=:equal)\n    p2 = plot(problem, states[k]; plot_type=:clarity, clims=(0, 1), aspect_ratio=:equal)\n    plot(p0, p1, p2, layout=(@layout [a b c]), size=(900, 600))\nend","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"@gif for k=1:length(states)\n    p0 = plot(synthetic_data, synthetic_data.ts[k]; clims=(-5, 5), cmap = :bluesreds, aspect_ratio=:equal)\n    title!(\"synthetic data\")\n    p1 = plot(problem, states[k]; plot_type=:estimate, clims=(-5, 5), cmap=:bluesreds, aspect_ratio=:equal)\n    \n    p2 = plot(problem, states[k]; plot_type=:percentile, percentile=0.05, clims=(-5, 5), cmap=:bluesreds, aspect_ratio=:equal)\n\n    p3 = plot(problem, states[k]; plot_type=:percentile, percentile=0.95, clims=(-5, 5), cmap=:bluesreds, aspect_ratio=:equal)\n    \n    plot(p0, p1, p2, p3, layout=(@layout [a b; c d]), size=(900, 600))\nend","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"Check if the data is within the estimate","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"tol = 0.1\n\nfs = Float64[]\nfor k=1:length(states)\n    M_05 = STGPKF.get_estimate_percentile(problem, states[k], tol/2)\n    M_95 = STGPKF.get_estimate_percentile(problem, states[k], (1 - tol/2))\n    M_true = vec(synthetic_data.data[:,:, k])\n    f = sum(M_05 .<= M_true .<= M_95) / length(M_true)\n    push!(fs, f)\nend\n\nplot(100*fs, label=\"Measured\")\nhline!([100*(1 - tol)], label=\"Theory\")\nxlabel!(\"Time step\")\ntitle!(\"Percent of points estimated within tol of accuracy\")\nylabel!(\"Percent [%]\")","category":"page"},{"location":"example/synthetic_data/","page":"Example","title":"Example","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SpatiotemporalGPs","category":"page"},{"location":"#SpatiotemporalGPs","page":"Home","title":"SpatiotemporalGPs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SpatiotemporalGPs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a complete example, see examples/synthetic_data.jl. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a quick-start, go to the quickstart page. ","category":"page"},{"location":"kf/#(Normal)-Kalman-Filtering","page":"Kalman Filters","title":"(Normal) Kalman Filtering","text":"","category":"section"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"This module provides an efficient and computationally stable method of computing and propagating a Kalman Filter estimate.  This module assumes a linear discrete time system. It can be a time-varying system. ","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"The system model is ","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"beginalign*\n  x_k+1 = A x_k + B u_k + w\n  y_k = C x_k + v\n  endalign*","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"where w sim mathcalN(0 W), v sim mathcalN(0 V).","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"Given x_k sim mathcalN(mu_kk P_kk), and the prediction step implements ","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"  beginalign*\n  mu_k+1k = A mu_kk + B u_k\n  P_k+1k = A P_kk A^T + W\n  endalign*","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"Then, given a measurement y_k+1, the correction step implements","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"beginalign*\nmu_k+1k+1 = mu_k+1k + K ( y_k+1 - C mu_k+1k)\nP_k+1k+1 = (I - K C) P_k+1k\nK = P_k+1k C^T (C P_k+1k C^T + V)^-1\nendalign*","category":"page"},{"location":"kf/#Initializing","page":"Kalman Filters","title":"Initializing","text":"","category":"section"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"To initialize the KF, ","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"s_0_0 = KFState(μ=μ, Σ=P) # estimated state at time k=0","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"which creates an KFState with mean μ and covariance P. Pass in the full matrix here.","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"To get the mean, covariance, or marginal standard deviations","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"μ(s) # returns the mean\nΣ(s) # returns the full covariance matrix\nσ(s) # returns the sqrt of the diagonal of the covariance matrix","category":"page"},{"location":"kf/#Predicting-and-Correcting","page":"Kalman Filters","title":"Predicting and Correcting","text":"","category":"section"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"You can run a prediction step","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"u_0 = # control input at time k=0\ns_1_0 = predict(s_0_0, A, B, u_0, W)","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"now s_1_0 = s_10  is the kf state at time k=1 conditioned on measurements upto time k=0. ","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"and then correct it use the measurement","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"y_1 = # measurement at time k=1\ns_1_1 = correct(s_1_0, y_1, C, V)","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"now s_1_1 = s_11 is the kf state at time k=1 conditioned on measurements upto time k=1. ","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"You can also do the prediction and correction in the same step:","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"s_1_1 = kalman_filter(s_0_0, y_1, u_0, A, B, C, V, W)","category":"page"},{"location":"kf/#Extracting-State-and-Covariances","page":"Kalman Filters","title":"Extracting State and Covariances","text":"","category":"section"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"To get the mean, covariance or standard deviations along the diagonal","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"  μ(s) # returns the mean\n  Σ(s) # returns the full covariance matrix\n  σ(s) # returns the sqrt of the diagonal of the covariance matrix","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"These getters are useful since the s.F component of KFStruct is such that Σ = FF^T. By storing only the upper triangular part of the matrix, we have an efficient implementation that is also computationally stable. ","category":"page"},{"location":"kf/#References","page":"Kalman Filters","title":"References","text":"","category":"section"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"This module basically implemented","category":"page"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"@article{tracy2022square,\n  title={A square-root kalman filter using only qr decompositions},\n  author={Tracy, Kevin},\n  journal={arXiv preprint arXiv:2208.06452},\n  year={2022}\n}","category":"page"},{"location":"kf/#Exported-Symbols","page":"Kalman Filters","title":"Exported Symbols","text":"","category":"section"},{"location":"kf/","page":"Kalman Filters","title":"Kalman Filters","text":"Modules = [KalmanFilter]\nPrivate = false","category":"page"},{"location":"kf/#SpatiotemporalGPs.KalmanFilter.KFState-Tuple{}-kf","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.KFState","text":"KFState(; μ, Σ, make_symmetric=true)\n\nA constructor for the Kalman Filter State, which is parameterized by the mean estimate and the covariance matrix. If make_symmetric is true, the covariance matrix is made symmetric internally. This is useful for numerical stability.\n\n\n\n\n\n","category":"method"},{"location":"kf/#SpatiotemporalGPs.KalmanFilter.KFState-kf","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.KFState","text":"KFState{V, MU}\n\nA type for the Kalman Filter State, which is parameterized by the types of the mean estimate and the upper triangular cholesky component of the covariance matrix.\n\n\n\n\n\n","category":"type"},{"location":"kf/#SpatiotemporalGPs.KalmanFilter.correct-Union{Tuple{S}, Tuple{S, Any, Any, Any}} where S<:KFState-kf","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.correct","text":"s_{k+1|k+1} = correct(s_{k+1|k}, y_{k+1}, C, V)\n\nUses the system model\n\ny_k+1 = C x_k+1 + v\n\nwhere v sim mathcalN(0 V) to correct the predicted state.\n\n\n\n\n\n","category":"method"},{"location":"kf/#SpatiotemporalGPs.KalmanFilter.get_Σ-Tuple{S} where S<:KFState-kf","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.get_Σ","text":"get_Σ(s::S) where {S <: KFState}\n\nGet the covariance matrix of the Kalman Filter State.\n\n\n\n\n\n","category":"method"},{"location":"kf/#SpatiotemporalGPs.KalmanFilter.get_μ-Tuple{S} where S<:KFState-kf","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.get_μ","text":"get_μ(s::S) where {S <: KFState}\n\nGet the mean estimate of the Kalman Filter State.\n\n\n\n\n\n","category":"method"},{"location":"kf/#SpatiotemporalGPs.KalmanFilter.get_σ-Tuple{S} where S<:KFState-kf","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.get_σ","text":"get_σ(s::S) where {S <: KFState}\n\nGet a vector of the standard deviation of the Kalman Filter State\n\n\n\n\n\n","category":"method"},{"location":"kf/#SpatiotemporalGPs.KalmanFilter.predict-Union{Tuple{S}, Tuple{S, Any, Any}} where S<:KFState-kf","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.predict","text":"s_{k+1|k} = predict(s_{k|k}, A, W)\n\nUses the system model\n\n  x_k+1 = A x_k + w\n\nwhere w  N(0 W) to predict the next state.\n\n\n\n\n\n","category":"method"},{"location":"kf/#SpatiotemporalGPs.KalmanFilter.predict-Union{Tuple{S}, Tuple{S, Vararg{Any, 4}}} where S<:KFState-kf","page":"Kalman Filters","title":"SpatiotemporalGPs.KalmanFilter.predict","text":"  s_{k+1} = predict(s_k, A, B, u_k, W)\n\nUses the system model\n\n  x_k+1 = A x_k + B u_k  + w\n\nwhere w  mathcalN(0 W) to predict the next state.\n\n\n\n\n\n","category":"method"}]
}
